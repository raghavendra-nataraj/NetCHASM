<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NetCHASM: HMStateManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NetCHASM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classHMStateManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HMStateManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68b4ed8ea4b59556882d98af8a91bd3d"><td class="memItemLeft" align="right" valign="top"><a id="a68b4ed8ea4b59556882d98af8a91bd3d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HMStateManager</b> (<a class="el" href="classHMStateManager.html">HMStateManager</a> &amp;)=delete</td></tr>
<tr class="separator:a68b4ed8ea4b59556882d98af8a91bd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dc0eab3ce38d630c4b5abd8b2e3a75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a63dc0eab3ce38d630c4b5abd8b2e3a75">updateState</a> (std::shared_ptr&lt; <a class="el" href="classHMState.html">HMState</a> &gt; &amp;current)</td></tr>
<tr class="memdesc:a63dc0eab3ce38d630c4b5abd8b2e3a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grab the latest version of the loaded state.  <a href="#a63dc0eab3ce38d630c4b5abd8b2e3a75">More...</a><br /></td></tr>
<tr class="separator:a63dc0eab3ce38d630c4b5abd8b2e3a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe677fc26cbce8a01e618d0b0c1dbd77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#abe677fc26cbce8a01e618d0b0c1dbd77">loadDaemonState</a> (const std::string &amp;masterConfig, HM_LOG_LEVEL logLevel)</td></tr>
<tr class="memdesc:abe677fc26cbce8a01e618d0b0c1dbd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the Daemon State and prepare the Daemon.  <a href="#abe677fc26cbce8a01e618d0b0c1dbd77">More...</a><br /></td></tr>
<tr class="separator:abe677fc26cbce8a01e618d0b0c1dbd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c45e377f62ea5ab7ffd9e0ed8ed50e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a9c45e377f62ea5ab7ffd9e0ed8ed50e7">reloadDaemonConfigs</a> (const std::string &amp;masterConfig)</td></tr>
<tr class="memdesc:a9c45e377f62ea5ab7ffd9e0ed8ed50e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reaload the Daemon.  <a href="#a9c45e377f62ea5ab7ffd9e0ed8ed50e7">More...</a><br /></td></tr>
<tr class="separator:a9c45e377f62ea5ab7ffd9e0ed8ed50e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9623e30cfbf34116babdec4d7d5148"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a0a9623e30cfbf34116babdec4d7d5148">reloadDaemonConfigs</a> ()</td></tr>
<tr class="memdesc:a0a9623e30cfbf34116babdec4d7d5148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reload the Daemon.  <a href="#a0a9623e30cfbf34116babdec4d7d5148">More...</a><br /></td></tr>
<tr class="separator:a0a9623e30cfbf34116babdec4d7d5148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff43a271bb7baee7df4121979a1a937"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a9ff43a271bb7baee7df4121979a1a937">healthCheck</a> (std::string masterConfig, HM_LOG_LEVEL logLevel)</td></tr>
<tr class="memdesc:a9ff43a271bb7baee7df4121979a1a937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main health check function.  <a href="#a9ff43a271bb7baee7df4121979a1a937">More...</a><br /></td></tr>
<tr class="separator:a9ff43a271bb7baee7df4121979a1a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa035de5db06292dc64f20a11b2e826c1"><td class="memItemLeft" align="right" valign="top"><a id="aa035de5db06292dc64f20a11b2e826c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#aa035de5db06292dc64f20a11b2e826c1">shutdown</a> ()</td></tr>
<tr class="memdesc:aa035de5db06292dc64f20a11b2e826c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown the Daemon. <br /></td></tr>
<tr class="separator:aa035de5db06292dc64f20a11b2e826c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd5dc476d429ac6bdb04b7641e33920"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#adbd5dc476d429ac6bdb04b7641e33920">startLogging</a> (uint32_t lastLogType, const std::string &amp;lastLogPath, HM_LOG_LEVEL lastLogLevel)</td></tr>
<tr class="memdesc:adbd5dc476d429ac6bdb04b7641e33920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start logging.  <a href="#adbd5dc476d429ac6bdb04b7641e33920">More...</a><br /></td></tr>
<tr class="separator:adbd5dc476d429ac6bdb04b7641e33920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2373964b6192db74c657be21ea83dc7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#af2373964b6192db74c657be21ea83dc7">getIdleThreads</a> ()</td></tr>
<tr class="memdesc:af2373964b6192db74c657be21ea83dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of idle threads in the work pool.  <a href="#af2373964b6192db74c657be21ea83dc7">More...</a><br /></td></tr>
<tr class="separator:af2373964b6192db74c657be21ea83dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4692b68bc9014078f21ac4871d5d2fcb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a4692b68bc9014078f21ac4871d5d2fcb">getEventQueueSize</a> ()</td></tr>
<tr class="memdesc:a4692b68bc9014078f21ac4871d5d2fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of timeouts in the event loop.  <a href="#a4692b68bc9014078f21ac4871d5d2fcb">More...</a><br /></td></tr>
<tr class="separator:a4692b68bc9014078f21ac4871d5d2fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9d423f3d7d2dd8b77e6fdb9b65124b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMEventLoopLibEvent.html">HMEventLoopLibEvent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a9e9d423f3d7d2dd8b77e6fdb9b65124b">getLibEvent</a> ()</td></tr>
<tr class="memdesc:a9e9d423f3d7d2dd8b77e6fdb9b65124b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the lib event instance for HTTP and DNS event lib queries.  <a href="#a9e9d423f3d7d2dd8b77e6fdb9b65124b">More...</a><br /></td></tr>
<tr class="separator:a9e9d423f3d7d2dd8b77e6fdb9b65124b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac869459d4c0821964f121eda2a046828"><td class="memItemLeft" align="right" valign="top">HM_LOG_LEVEL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#ac869459d4c0821964f121eda2a046828">getLogLevel</a> ()</td></tr>
<tr class="memdesc:ac869459d4c0821964f121eda2a046828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current log level.  <a href="#ac869459d4c0821964f121eda2a046828">More...</a><br /></td></tr>
<tr class="separator:ac869459d4c0821964f121eda2a046828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32db1e7b393b95bb513837ef8366f6ed"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a32db1e7b393b95bb513837ef8366f6ed">getNThreads</a> () const</td></tr>
<tr class="memdesc:a32db1e7b393b95bb513837ef8366f6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of threads running in the work pool.  <a href="#a32db1e7b393b95bb513837ef8366f6ed">More...</a><br /></td></tr>
<tr class="separator:a32db1e7b393b95bb513837ef8366f6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9427d8de8f7c334e51dac1c330bb63"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#aad9427d8de8f7c334e51dac1c330bb63">getMonitorFrequency</a> () const</td></tr>
<tr class="memdesc:aad9427d8de8f7c334e51dac1c330bb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current timeout between updating the thread monitoring stats.  <a href="#aad9427d8de8f7c334e51dac1c330bb63">More...</a><br /></td></tr>
<tr class="separator:aad9427d8de8f7c334e51dac1c330bb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53497b28741d0c73e2f8959b3ccc0aca"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a53497b28741d0c73e2f8959b3ccc0aca">getStridePercent</a> () const</td></tr>
<tr class="memdesc:a53497b28741d0c73e2f8959b3ccc0aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current stride percent.  <a href="#a53497b28741d0c73e2f8959b3ccc0aca">More...</a><br /></td></tr>
<tr class="separator:a53497b28741d0c73e2f8959b3ccc0aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39701970c2e6e83149fea253761c4408"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a39701970c2e6e83149fea253761c4408">getWorkPerThreadRatio</a> () const</td></tr>
<tr class="memdesc:a39701970c2e6e83149fea253761c4408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current worker to thread ratio.  <a href="#a39701970c2e6e83149fea253761c4408">More...</a><br /></td></tr>
<tr class="separator:a39701970c2e6e83149fea253761c4408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dee7d18c8f46b3bc76ec693cdc1b86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a96dee7d18c8f46b3bc76ec693cdc1b86">isRecycle</a> () const</td></tr>
<tr class="memdesc:a96dee7d18c8f46b3bc76ec693cdc1b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get if the work pool is using thread recycling.  <a href="#a96dee7d18c8f46b3bc76ec693cdc1b86">More...</a><br /></td></tr>
<tr class="separator:a96dee7d18c8f46b3bc76ec693cdc1b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8ff5bcbf0262e37d2515067e244ae1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a0d8ff5bcbf0262e37d2515067e244ae1">setLogLevel</a> (HM_LOG_LEVEL level)</td></tr>
<tr class="memdesc:a0d8ff5bcbf0262e37d2515067e244ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current log level.  <a href="#a0d8ff5bcbf0262e37d2515067e244ae1">More...</a><br /></td></tr>
<tr class="separator:a0d8ff5bcbf0262e37d2515067e244ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415393f6a82ca5f4a5be2c7568b3ba95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a415393f6a82ca5f4a5be2c7568b3ba95">setMonitorFrequency</a> (uint32_t monitorFrequency)</td></tr>
<tr class="memdesc:a415393f6a82ca5f4a5be2c7568b3ba95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current timeout between updating the thread monitoring stats.  <a href="#a415393f6a82ca5f4a5be2c7568b3ba95">More...</a><br /></td></tr>
<tr class="separator:a415393f6a82ca5f4a5be2c7568b3ba95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab0d1db9a8cb51c490c9ec0a6c4f555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#adab0d1db9a8cb51c490c9ec0a6c4f555">setStridePercent</a> (uint32_t stridePercent)</td></tr>
<tr class="memdesc:adab0d1db9a8cb51c490c9ec0a6c4f555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current stride percent.  <a href="#adab0d1db9a8cb51c490c9ec0a6c4f555">More...</a><br /></td></tr>
<tr class="separator:adab0d1db9a8cb51c490c9ec0a6c4f555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871c1d6588dc23e9ff2ff695c0921b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a871c1d6588dc23e9ff2ff695c0921b6b">setWorkPerThreadRatio</a> (uint32_t workPerThreadRatio)</td></tr>
<tr class="memdesc:a871c1d6588dc23e9ff2ff695c0921b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the work per thread ratio.  <a href="#a871c1d6588dc23e9ff2ff695c0921b6b">More...</a><br /></td></tr>
<tr class="separator:a871c1d6588dc23e9ff2ff695c0921b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf3202ec835a13bac45711b4a2c66e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a6cf3202ec835a13bac45711b4a2c66e9">setRecycle</a> (bool recycle)</td></tr>
<tr class="memdesc:a6cf3202ec835a13bac45711b4a2c66e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current thread pool to use thread recycle.  <a href="#a6cf3202ec835a13bac45711b4a2c66e9">More...</a><br /></td></tr>
<tr class="separator:a6cf3202ec835a13bac45711b4a2c66e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356bd51e102b65e0442fc9dd7096f53e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#a356bd51e102b65e0442fc9dd7096f53e">setState</a> (std::shared_ptr&lt; <a class="el" href="classHMState.html">HMState</a> &gt; debugState)</td></tr>
<tr class="memdesc:a356bd51e102b65e0442fc9dd7096f53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually set the state into the HMStateMaster instance.  <a href="#a356bd51e102b65e0442fc9dd7096f53e">More...</a><br /></td></tr>
<tr class="separator:a356bd51e102b65e0442fc9dd7096f53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af3cac1d579d715b527f4d276fea82f4a"><td class="memItemLeft" align="right" valign="top"><a id="af3cac1d579d715b527f4d276fea82f4a"></a>
<a class="el" href="classHMWorkQueue.html">HMWorkQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMStateManager.html#af3cac1d579d715b527f4d276fea82f4a">m_workQueue</a></td></tr>
<tr class="memdesc:af3cac1d579d715b527f4d276fea82f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Work Queue. <br /></td></tr>
<tr class="separator:af3cac1d579d715b527f4d276fea82f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae33f8244a617381afa3a9aedf7a155bf"><td class="memItemLeft" align="right" valign="top"><a id="ae33f8244a617381afa3a9aedf7a155bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_keepRunning</b></td></tr>
<tr class="separator:ae33f8244a617381afa3a9aedf7a155bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71b712c0782dccdd6136a65dcef0046"><td class="memItemLeft" align="right" valign="top"><a id="aa71b712c0782dccdd6136a65dcef0046"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><b>m_shutdownCond</b></td></tr>
<tr class="separator:aa71b712c0782dccdd6136a65dcef0046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568f516804d47e8726682bc1832c3661"><td class="memItemLeft" align="right" valign="top"><a id="a568f516804d47e8726682bc1832c3661"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>m_shutdownMutex</b></td></tr>
<tr class="separator:a568f516804d47e8726682bc1832c3661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f3fa360ef53bbc8880dd4298955a68"><td class="memItemLeft" align="right" valign="top"><a id="a13f3fa360ef53bbc8880dd4298955a68"></a>
<a class="el" href="classHMEventLoop.html">HMEventLoop</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_eventLoop</b></td></tr>
<tr class="separator:a13f3fa360ef53bbc8880dd4298955a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f18a2a704b9e57786ea5dd1bffcddca"><td class="memItemLeft" align="right" valign="top"><a id="a0f18a2a704b9e57786ea5dd1bffcddca"></a>
<a class="el" href="classHMThreadPool.html">HMThreadPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_threadPool</b></td></tr>
<tr class="separator:a0f18a2a704b9e57786ea5dd1bffcddca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe5a9009af9f2b2a3f841237e44f5b6"><td class="memItemLeft" align="right" valign="top"><a id="abfe5a9009af9f2b2a3f841237e44f5b6"></a>
<a class="el" href="classHMEventLoopLibEvent.html">HMEventLoopLibEvent</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_libEvent</b></td></tr>
<tr class="separator:abfe5a9009af9f2b2a3f841237e44f5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0412518ddeb5960edb5733d78ab827"><td class="memItemLeft" align="right" valign="top"><a id="aef0412518ddeb5960edb5733d78ab827"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>m_reloadMutex</b></td></tr>
<tr class="separator:aef0412518ddeb5960edb5733d78ab827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4bc4dcf8341a23672fd1533df48386"><td class="memItemLeft" align="right" valign="top"><a id="a3b4bc4dcf8341a23672fd1533df48386"></a>
std::shared_ptr&lt; <a class="el" href="classHMState.html">HMState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_currentState</b></td></tr>
<tr class="separator:a3b4bc4dcf8341a23672fd1533df48386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d172418e3a7d9ae9bfdad88c131ef1"><td class="memItemLeft" align="right" valign="top"><a id="a48d172418e3a7d9ae9bfdad88c131ef1"></a>
std::shared_ptr&lt; <a class="el" href="classHMState.html">HMState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_newState</b></td></tr>
<tr class="separator:a48d172418e3a7d9ae9bfdad88c131ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4265eb97bffbdf0e29d2e21318e811c"><td class="memItemLeft" align="right" valign="top"><a id="ac4265eb97bffbdf0e29d2e21318e811c"></a>
std::unique_ptr&lt; <a class="el" href="classHMCommandListenerBase.html">HMCommandListenerBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_listener</b></td></tr>
<tr class="separator:ac4265eb97bffbdf0e29d2e21318e811c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4692b68bc9014078f21ac4871d5d2fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4692b68bc9014078f21ac4871d5d2fcb">&#9670;&nbsp;</a></span>getEventQueueSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t HMStateManager::getEventQueueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of timeouts in the event loop. </p>
<p>Get the number of timeout in the event loop. </p><dl class="section return"><dt>Returns</dt><dd>the number of events in the event loop. </dd></dl>

</div>
</div>
<a id="af2373964b6192db74c657be21ea83dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2373964b6192db74c657be21ea83dc7">&#9670;&nbsp;</a></span>getIdleThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t HMStateManager::getIdleThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of idle threads in the work pool. </p>
<p>Get the number of idle threads in the work pool. </p><dl class="section return"><dt>Returns</dt><dd>the number of idle threads in the work pool. </dd></dl>

</div>
</div>
<a id="a9e9d423f3d7d2dd8b77e6fdb9b65124b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9d423f3d7d2dd8b77e6fdb9b65124b">&#9670;&nbsp;</a></span>getLibEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMEventLoopLibEvent.html">HMEventLoopLibEvent</a>* HMStateManager::getLibEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the lib event instance for HTTP and DNS event lib queries. </p>
<p>Get a pointer to the lib event instance for HTTP and DNS event lib queries. </p><dl class="section return"><dt>Returns</dt><dd>a pointer to the current <a class="el" href="classHMEventLoopLibEvent.html" title="Event loop implementation using the LibEvent framework. ">HMEventLoopLibEvent</a> instance defined for use. </dd></dl>

</div>
</div>
<a id="ac869459d4c0821964f121eda2a046828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac869459d4c0821964f121eda2a046828">&#9670;&nbsp;</a></span>getLogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HM_LOG_LEVEL HMStateManager::getLogLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current log level. </p>
<p>Get the current log level for the running logger. </p><dl class="section return"><dt>Returns</dt><dd>the current log level for the running logger. </dd></dl>

</div>
</div>
<a id="aad9427d8de8f7c334e51dac1c330bb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9427d8de8f7c334e51dac1c330bb63">&#9670;&nbsp;</a></span>getMonitorFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t HMStateManager::getMonitorFrequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current timeout between updating the thread monitoring stats. </p>
<p>Get the current timeout between updating the thread monitoring stats. </p><dl class="section return"><dt>Returns</dt><dd>the current timeout between updating the thread monitoring stats. </dd></dl>

</div>
</div>
<a id="a32db1e7b393b95bb513837ef8366f6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32db1e7b393b95bb513837ef8366f6ed">&#9670;&nbsp;</a></span>getNThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t HMStateManager::getNThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of threads running in the work pool. </p>
<p>Get the number of threads running in the work pool. </p><dl class="section return"><dt>Returns</dt><dd>the number of threads running in the work pool. </dd></dl>

</div>
</div>
<a id="a53497b28741d0c73e2f8959b3ccc0aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53497b28741d0c73e2f8959b3ccc0aca">&#9670;&nbsp;</a></span>getStridePercent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t HMStateManager::getStridePercent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current stride percent. </p>
<p>Get the current stride percent for the work pool. The stride percent is the percentage of idle threads allowed before the Daemon adjusts the thread count lower. </p><dl class="section return"><dt>Returns</dt><dd>the current stride percent. </dd></dl>

</div>
</div>
<a id="a39701970c2e6e83149fea253761c4408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39701970c2e6e83149fea253761c4408">&#9670;&nbsp;</a></span>getWorkPerThreadRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t HMStateManager::getWorkPerThreadRatio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current worker to thread ratio. </p>
<p>Get the current worker to thread ratio. The worker to thread ratio is used to calibrate the number of threads when the pool increases the thread count. It will increase to work queue length / worker per thread ratio. </p><dl class="section return"><dt>Returns</dt><dd>the current worker to thread ratio. </dd></dl>

</div>
</div>
<a id="a9ff43a271bb7baee7df4121979a1a937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff43a271bb7baee7df4121979a1a937">&#9670;&nbsp;</a></span>healthCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMStateManager::healthCheck </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>masterConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HM_LOG_LEVEL&#160;</td>
          <td class="paramname"><em>logLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main health check function. </p>
<p>Main health check function. This is the class that should be called from the main or guardian process. Runs the entire Daemon starting with a config load. Sets up the event handler, work queues, control sockets and all necessary threads to run the daemon. Catches interrupt signals to force the Daemon to shut down. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>master config to parse when loading the Daemon.  the log level to use for all event logging. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false upon failure. </dd></dl>

</div>
</div>
<a id="a96dee7d18c8f46b3bc76ec693cdc1b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96dee7d18c8f46b3bc76ec693cdc1b86">&#9670;&nbsp;</a></span>isRecycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMStateManager::isRecycle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get if the work pool is using thread recycling. </p>
<p>Get if the work pool is using thread recycling. Thread recycling will periodically flush thread state for long running Curl and Ares library state. </p><dl class="section return"><dt>Returns</dt><dd>true if thread recycling is on. </dd></dl>

</div>
</div>
<a id="abe677fc26cbce8a01e618d0b0c1dbd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe677fc26cbce8a01e618d0b0c1dbd77">&#9670;&nbsp;</a></span>loadDaemonState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMStateManager::loadDaemonState </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>masterConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HM_LOG_LEVEL&#160;</td>
          <td class="paramname"><em>logLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the Daemon State and prepare the Daemon. </p>
<p>Load the Daemon State and prepare the Daemon. Should only be called on initial load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>master config to parse. </td></tr>
    <tr><td class="paramname">the</td><td>HM_LOG_LEVEL to use for logging. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success. </dd></dl>

</div>
</div>
<a id="a9c45e377f62ea5ab7ffd9e0ed8ed50e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c45e377f62ea5ab7ffd9e0ed8ed50e7">&#9670;&nbsp;</a></span>reloadDaemonConfigs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMStateManager::reloadDaemonConfigs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>masterConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reaload the Daemon. </p>
<p>Trigger a reload of the Daemon state. The new state will re-parse the master and health check configs. The reload function will copy state from the current state to the new state replacing the new state to the current before returning. The function takes care of rescheduling health checks and DNS resolutions. It also garbage collects the old state before returning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>new master config to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on a successful reload. </dd></dl>

</div>
</div>
<a id="a0a9623e30cfbf34116babdec4d7d5148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9623e30cfbf34116babdec4d7d5148">&#9670;&nbsp;</a></span>reloadDaemonConfigs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMStateManager::reloadDaemonConfigs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reload the Daemon. </p>
<p>Trigger a reload of the Daemon state. The new state will re-parse the current master and health check configs. The reload function will copy state from the current state to the new state replacing the new state to the current before returning. The function takes care of rescheduling health checks and DNS resolutions. It also garbage collects the old state before returning. </p><dl class="section return"><dt>Returns</dt><dd>true on a successful reload. </dd></dl>

</div>
</div>
<a id="a0d8ff5bcbf0262e37d2515067e244ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8ff5bcbf0262e37d2515067e244ae1">&#9670;&nbsp;</a></span>setLogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMStateManager::setLogLevel </td>
          <td>(</td>
          <td class="paramtype">HM_LOG_LEVEL&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current log level. </p>
<p>Set the current log level for the running logger. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>new log level for the running logger. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a415393f6a82ca5f4a5be2c7568b3ba95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415393f6a82ca5f4a5be2c7568b3ba95">&#9670;&nbsp;</a></span>setMonitorFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMStateManager::setMonitorFrequency </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>monitorFrequency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current timeout between updating the thread monitoring stats. </p>
<p>Set the current timeout between updating the thread monitoring stats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>new time between updating the thread monitoring stats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cf3202ec835a13bac45711b4a2c66e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf3202ec835a13bac45711b4a2c66e9">&#9670;&nbsp;</a></span>setRecycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMStateManager::setRecycle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recycle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current thread pool to use thread recycle. </p>
<p>Set the current thread pool to use thread recycling. Thread recycling will periodically flush thread state for long running Curl and Ares library state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">true</td><td>to enable thread recycling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a356bd51e102b65e0442fc9dd7096f53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356bd51e102b65e0442fc9dd7096f53e">&#9670;&nbsp;</a></span>setState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMStateManager::setState </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classHMState.html">HMState</a> &gt;&#160;</td>
          <td class="paramname"><em>debugState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually set the state into the HMStateMaster instance. </p>
<p>Force the given state into the HMStateMaster. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>state to use as the new <a class="el" href="classHMState.html" title="The core state class for NetCHASM. ">HMState</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adab0d1db9a8cb51c490c9ec0a6c4f555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab0d1db9a8cb51c490c9ec0a6c4f555">&#9670;&nbsp;</a></span>setStridePercent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMStateManager::setStridePercent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stridePercent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current stride percent. </p>
<p>Set the current stride percent. The stride percent is the percentage of idle threads allowed before the Daemon adjusts the thread count lower. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>new stride percent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a871c1d6588dc23e9ff2ff695c0921b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871c1d6588dc23e9ff2ff695c0921b6b">&#9670;&nbsp;</a></span>setWorkPerThreadRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMStateManager::setWorkPerThreadRatio </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>workPerThreadRatio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the work per thread ratio. </p>
<p>Set the work per thread ratio. The worker to thread ratio is used to calibrate the number of threads when the pool increases the thread count. It will increase to work queue length / worker per thread ratio. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>new work per thread ratio. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbd5dc476d429ac6bdb04b7641e33920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd5dc476d429ac6bdb04b7641e33920">&#9670;&nbsp;</a></span>startLogging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMStateManager::startLogging </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lastLogType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lastLogPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HM_LOG_LEVEL&#160;</td>
          <td class="paramname"><em>lastLogLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start logging. </p>
<p>Start the logging. Either during initial setup or during a reload. Deals with starting the logging defined in the master config. If that logging fails, starts logging to syslog. If syslog fails, starts logging to stdout. If the stdout fails, it will drop back to logging to the previous source. If the previous logging and new logging are the same, the function does nothing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>last log type before the start logging call. (The type we are replacing). </td></tr>
    <tr><td class="paramname">the</td><td>last log path. </td></tr>
    <tr><td class="paramname">the</td><td>last log level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the logger is logging regardless of what type ended up being opened. </dd></dl>

</div>
</div>
<a id="a63dc0eab3ce38d630c4b5abd8b2e3a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dc0eab3ce38d630c4b5abd8b2e3a75">&#9670;&nbsp;</a></span>updateState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMStateManager::updateState </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classHMState.html">HMState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>current</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Grab the latest version of the loaded state. </p>
<p>Grab the latest version of the loaded state. Various classes in the codebase can keep a shared pointer on the state. Calling the update function at set times allows the work to finish and smoothly switch to a new state. During a relaod, the reloader willl only garbage collect when the work has updated the shared pointer. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/internal/<a class="el" href="HMStateManager_8h_source.html">HMStateManager.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
